// скачиваете проект
// npm i устанавливаете зависимости
// npm start - запуск проекта

// default может быть только один в файле
// могу переименовать при импорте

// экспорт дефолтный - без фигурных скобок
// экспорт обычный - с фигурными скобками

// могу прописать логику
// return всегда возвращает один тег
// один родительский элемент обарчивает все остальные
// JSX - смесь html + js - функция которая возвращает html

// hook специальный API который работает только с ФУНКЦИОНАЛЬНЫМИ компонентами
// use - начинаются с этого слова
// вызываются на верхнем уровне компонента
// не можем писать хуки вусловиях или циклах

//значение фунцкция кот меняет значение //первоначнальное значение
// состояние - динамическая часть(изщменяемая часть компонента)
// МЫ НЕ МОЖЕМ МЕНЯТЬ СОСТОЯНИЕ НАПРЯМУЮ
// изменяем состояние через функцию set
// React отслеживает изменение переменной и перерендр компонент

// значение состояние может быть любым типом данных
// строка число бул объект массив
// в initState можем передать функцию
// null

// все вычисления до return
// return возвращает всегда один элемент HTML
// не просто id а ключ элемента в списке
sf 4

// LS - хранилище данных в БРАУЗЕРЕ
// ключ - значение (строка)
// хранятся пока не удалим сами
// до 10 мб

// Todos Page
// выносим логику в компонент заносим todos в useState()
// передаем в TodoList пропс
// создаем отдельный компонент AddNewTodo в котором реализовываем логику добавления
// как сделали с user

// const context = useContext(ApiContext)
// const posts = context.posts
// 6 и 7 вместе
// console.log('context: ', context)
// const posts = context.posts
// const handlePostedData = context.handlePostedData

// const { posts, handlePostedData } = context

// 1. Создаем функцию кот фетчит данные одного поста - id, callback, async await export try catch
// 2. Создаем Страницу SinglePostPage
// 3. index - добавляем rout - post/:id
// 4. на странице PostPage оборачиваем внутри map каждый элемент в Link
// 5. внутри добавляем пусть по айди и key переносим в него
// 6. внутри SinglePostPage достаем id поста
// 7. Создаем состояние для поста
// 8. заносим внтури useEffect результат запроса в состояние компонента
// 9. отрисовываем данные поста

// Главная страница
// Страница с категориями
// Страница с товарами - Страница со всеми/Страница товаров со скидками/Страница товаров по категории
// Страница отдельного товара
// Корзина
// Ошибки

// Создать все страницы - Заглушки
// Настроить routing

Первая неделя: 0. Создать все страницы - Заглушки

1. Создать навигационное меню - все обернуть в NavLink
   добавить стили
2. index.js создаем Routes для категорий(отдельная категория) и тд.
3. Сделать страницу ошибки
4. Сделать страницу с категориями - реализовать
   список категорий каждая обернута в Link
5. Создаете страницу отдельного товара

Вторая неделя:

6. Страница с товарами отдельной категории 7. Страница всех товаров 8. Страница товаров со скидкой
   ProductsPage.jsx - принимает параметры 9. задача со звездочкой - сделать страницу товаров - прокидывать пропс и в зависимости от пропсов отрисовывать нужные данные НА ПОДУМАТЬ

7. Страница корзины (rtk)

СОСТОЯНИЕ в РЕАКТЕ(РЕДАКС)

есть какие-то данные, кот изменяются в приложении/компонетах

состояние - определенныйрезультат изменений на текущий момент

1. Компонент - у компонента есть состояние (данные на текущий момент), потому что состояние изменяется
   а) У функционального компонента есть специальный инструмент, кот позволяет им управлять - хук useState
   НО! это не единственный вариант управления состояния
   в классовых компонентах нет хуков, поэтому в них изменения состояния будут через методы классового компонента
2. Возможно передавать состояние в несколько компонентов, чтобы ими управлять - useContext
   хранится в одном компоненте, это состояние влияет на несколько компонентов
3. ГЛОБАЛЬНОЕ СОСТОЯНИЕ приложение целиком - REDUX

в зависимости от целей выбираем необходимый
в приложении могут существовать - useState, useContext, redux

HTML-CSS-JS-REACT / Redux-TypeScript + вопросы по различным библиотекам

// позволяет получить значение из store
// принимает в себя CALLBACK
//You must pass a selector to useSelector
const counter = useSelector((store) => store.counter)
// ОН позволяет отправить наши действия(actions) в reducer
// action -> объект у которого два поля - type и payload
// const action = {
// type: 'TYPE',
// payload: 'OPTIONAL',
// }
// action в dispatch

import { configureStore } from '@reduxjs/toolkit'
import counterReducer from './counterSlice'
// наше состояние хранится в сторе
// каждый раз когда мы используем dispatch вызывается функция reducer
// reducer возвр новое состояние(измененное)
// createStore(counterReducer) - благодаря этой строчке обновляется store
// в провайдере тоже обновляется значение
// компоненты перерисовываются

// configureStore заменяет createStore - принимает в себя объект с ключом reducer
export const store = configureStore({ reducer: counterReducer })

RTK

1. Создать небольшое приложение, которое будет менять и сбрасывать цвет заднего фото
2. Создавать приложение которое меняет тему приложения
3. Есть список пользователей, создаем функционал добавления пользователей в друзья

2) создаем файл colorSlice
3) создать initialState {color: #ffffff}
4) создать slice --> createSlice

// useState() useContext() useReducer() redux
// данные кот. приходят - fetch() внешний API
// различные инструменты для работы с внешним
// error, isLoading, isSubmitting, isSubmitted, isError
// rtk query позволяет получить доступ к загрузке и ошибкам
// позволяет нам хранить наши данные и запросы в одном месте
// rtk отслеживает используя спец встроенные методы изменения в полученных с сервера данных

Custom Hooks

1. useInput
2. useLocalStorage
3. useDebounce() - отложить какое-то действие на опрееделенное время

4. Как вынести логику фильтрации в отдельный кастомный хук

5. Библиотека внешняя для работы с кастомными хуки
